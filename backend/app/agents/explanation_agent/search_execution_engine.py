import asyncio
from typing import Dict, Any, List

class SearchExecutor:
    def __init__(self):
        # Import your existing search tools
        from app.agents.explanation_agent.tavily_search.tavily_contextual_search import tavily_contextual_search
        from app.agents.explanation_agent.tavily_search.tavily_multi_query_search import tavily_multi_query_search
        from app.agents.explanation_agent.tavily_search.tavily_specialized_search import (
            tavily_news_search, tavily_academic_search, tavily_financial_search, tavily_industry_search
        )
        from app.agents.explanation_agent.tavily_search.tavily_universal_search import tavily_universal_search
        
        self.tools = {
            "tavily_contextual_search": tavily_contextual_search,
            "tavily_multi_query_search": tavily_multi_query_search,
            "tavily_news_search": tavily_news_search,
            "tavily_academic_search": tavily_academic_search,
            "tavily_financial_search": tavily_financial_search,
            "tavily_industry_search": tavily_industry_search,
            "tavily_universal_search": tavily_universal_search
        }
    
    async def execute_search_plan(self, search_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the search plan generated by LLM."""
        
        search_calls = search_plan.get("search_calls", [])
        execution_strategy = search_plan.get("execution_strategy", "sequential")
        
        results = {
            "analysis": search_plan.get("analysis", ""),
            "search_results": [],
            "execution_summary": {
                "total_searches": len(search_calls),
                "execution_strategy": execution_strategy,
                "expected_coverage": search_plan.get("expected_coverage", "")
            }
        }
        
        if execution_strategy == "parallel":
            # Execute searches in parallel
            tasks = []
            for search_call in search_calls:
                task = self._execute_single_search(search_call)
                tasks.append(task)
            
            search_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, result in enumerate(search_results):
                if not isinstance(result, Exception):
                    results["search_results"].append({
                        "tool": search_calls[i]["tool"],
                        "query": search_calls[i]["query"],
                        "reasoning": search_calls[i]["reasoning"],
                        "result": result
                    })
                else:
                    print("Error executing parallel search:", result)
                    results["search_results"].append({
                        "tool": search_calls[i]["tool"],
                        "query": search_calls[i]["query"],
                        "reasoning": search_calls[i]["reasoning"],
                        "error": str(result)
                    })
        else:
            # Execute searches sequentially
            for search_call in search_calls:
                try:
                    result = await self._execute_single_search(search_call)
                    results["search_results"].append({
                        "tool": search_call["tool"],
                        "query": search_call["query"],
                        "reasoning": search_call["reasoning"],
                        "result": result
                    })
                except Exception as e:
                    print("Error executing sequential search:", result)
                    results["search_results"].append({
                        "tool": search_call["tool"],
                        "query": search_call["query"],
                        "reasoning": search_call["reasoning"],
                        "error": str(e)
                    })
        
        return results
    
    async def _execute_single_search(self, search_call: Dict[str, Any]) -> str:
        """Execute a single search call."""
        tool_name = search_call["tool"]
        query = search_call["query"]
        parameters = search_call.get("parameters", {})
        
        if tool_name not in self.tools:
            raise ValueError(f"Unknown search tool: {tool_name}")
        
        tool = self.tools[tool_name]
        
        # Prepare parameters for the tool
        tool_params = {"query": query}
        tool_params.update(parameters)
        
        # Execute the search
        result = await tool.ainvoke(tool_params)
        return result
